# 全球新闻管理系统 - 常见问题与解决方案详细文档

## 1. 概述

本文档详细列出全球新闻管理系统在开发和使用过程中可能遇到的常见问题，并提供相应的解决方案，帮助开发人员和用户快速解决问题。

## 2. 登录问题

### 2.1 登录失败

#### 2.1.1 问题描述

用户无法登录系统，提示"用户名或密码错误"。

#### 2.1.2 可能原因

1. 用户名或密码输入错误
2. 用户账号被锁定或禁用
3. 后端验证服务异常
4. 前端请求格式错误
5. 网络连接问题

#### 2.1.3 解决方案

1. **检查用户名和密码**

   确认用户名和密码输入正确，注意大小写和空格。

2. **检查账号状态**

   ```javascript
   // 前端检查用户状态的示例代码
   async function checkUserStatus(username) {
     try {
       const response = await axios.get(`/api/users/status/${username}`);
       if (response.data.status === 'locked') {
         message.error('账号已被锁定，请联系管理员');
         return false;
       } else if (response.data.status === 'disabled') {
         message.error('账号已被禁用，请联系管理员');
         return false;
       }
       return true;
     } catch (error) {
       console.error('检查用户状态失败:', error);
       message.error('系统异常，请稍后再试');
       return false;
     }
   }
   ```

3. **检查后端服务**

   ```bash
   # 检查后端服务状态
   curl -I http://localhost:5000/api/health
   ```

4. **检查请求格式**

   ```javascript
   // 正确的登录请求格式
   const loginData = {
     username: username.trim(),
     password: password,
     remember: rememberMe
   };
   
   try {
     const response = await axios.post('/api/auth/login', loginData);
     // 处理响应
   } catch (error) {
     // 错误处理
     console.error('登录请求错误:', error.response?.data || error.message);
   }
   ```

5. **网络问题排查**

   - 检查浏览器控制台网络请求
   - 检查是否有跨域问题
   - 检查网络连接状态

### 2.2 登录后无权限

#### 2.2.1 问题描述

用户成功登录后，无法访问应有的功能模块，或提示无权限。

#### 2.2.2 可能原因

1. 用户角色配置错误
2. 权限数据获取失败
3. 前端权限判断逻辑错误
4. 后端权限验证错误

#### 2.2.3 解决方案

1. **检查用户角色**

   ```javascript
   // 检查用户角色和权限
   function checkUserRole() {
     const userInfo = JSON.parse(localStorage.getItem('userInfo'));
     console.log('当前用户角色:', userInfo?.role);
     console.log('当前用户权限:', userInfo?.permissions);
     
     // 验证权限是否正确加载
     if (!userInfo?.permissions || userInfo.permissions.length === 0) {
       message.warning('用户权限数据异常，请重新登录');
       return false;
     }
     return true;
   }
   ```

2. **重新获取权限数据**

   ```javascript
   // 重新获取用户权限数据
   async function refreshPermissions() {
     try {
       const response = await axios.get('/api/users/permissions', {
         headers: {
           Authorization: `Bearer ${localStorage.getItem('token')}`
         }
       });
       
       if (response.data && response.data.permissions) {
         // 更新本地存储的权限数据
         const userInfo = JSON.parse(localStorage.getItem('userInfo'));
         userInfo.permissions = response.data.permissions;
         localStorage.setItem('userInfo', JSON.stringify(userInfo));
         
         message.success('权限数据已更新');
         // 刷新页面以应用新权限
         window.location.reload();
       }
     } catch (error) {
       console.error('获取权限数据失败:', error);
       message.error('获取权限数据失败，请重新登录');
     }
   }
   ```

3. **检查前端权限判断**

   ```javascript
   // 权限检查函数
   export function hasPermission(permissionCode) {
     const userInfo = JSON.parse(localStorage.getItem('userInfo'));
     if (!userInfo || !userInfo.permissions) {
       return false;
     }
     
     // 超级管理员拥有所有权限
     if (userInfo.role === 'superadmin') {
       return true;
     }
     
     return userInfo.permissions.includes(permissionCode);
   }
   
   // 使用示例
   const canEdit = hasPermission('news:edit');
   if (canEdit) {
     // 显示编辑按钮
   } else {
     // 隐藏编辑按钮
   }
   ```

4. **检查后端权限验证**

   ```javascript
   // 后端权限验证中间件示例
   const checkPermission = (requiredPermission) => {
     return (req, res, next) => {
       const user = req.user;
       
       // 检查用户是否存在
       if (!user) {
         return res.status(401).json({ message: '未授权，请先登录' });
       }
       
       // 超级管理员拥有所有权限
       if (user.role === 'superadmin') {
         return next();
       }
       
       // 检查用户是否有所需权限
       if (!user.permissions || !user.permissions.includes(requiredPermission)) {
         return res.status(403).json({ message: '无权限执行此操作' });
       }
       
       next();
     };
   };
   
   // 使用示例
   router.post('/news', checkPermission('news:create'), createNews);
   ```

### 2.3 Token 过期问题

#### 2.3.1 问题描述

用户在使用过程中突然被登出，或操作时提示"登录已过期，请重新登录"。

#### 2.3.2 可能原因

1. JWT Token 已过期
2. Token 被服务器端强制失效
3. Token 存储丢失

#### 2.3.3 解决方案

1. **Token 自动刷新机制**

   ```javascript
   // axios 请求拦截器，处理 Token 过期
   axios.interceptors.response.use(
     response => response,
     async error => {
       const originalRequest = error.config;
       
       // 如果是 401 错误且未尝试过刷新 Token
       if (error.response?.status === 401 && !originalRequest._retry) {
         originalRequest._retry = true;
         
         try {
           // 尝试使用刷新 Token 获取新的访问 Token
           const refreshToken = localStorage.getItem('refreshToken');
           if (!refreshToken) {
             // 无刷新 Token，需要重新登录
             redirectToLogin();
             return Promise.reject(error);
           }
           
           const response = await axios.post('/api/auth/refresh-token', {
             refreshToken
           });
           
           // 更新存储的 Token
           const { token, refreshToken: newRefreshToken } = response.data;
           localStorage.setItem('token', token);
           localStorage.setItem('refreshToken', newRefreshToken);
           
           // 更新请求头并重试原始请求
           axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
           originalRequest.headers['Authorization'] = `Bearer ${token}`;
           
           return axios(originalRequest);
         } catch (refreshError) {
           // 刷新 Token 失败，需要重新登录
           redirectToLogin();
           return Promise.reject(refreshError);
         }
       }
       
       return Promise.reject(error);
     }
   );
   
   // 重定向到登录页
   function redirectToLogin() {
     // 清除本地存储的认证信息
     localStorage.removeItem('token');
     localStorage.removeItem('refreshToken');
     localStorage.removeItem('userInfo');
     
     // 保存当前路径，登录后可以返回
     localStorage.setItem('redirectPath', window.location.pathname);
     
     // 跳转到登录页
     window.location.href = '/login';
   }
   ```

2. **定期检查 Token 有效性**

   ```javascript
   // 定期检查 Token 有效性
   function setupTokenValidityCheck() {
     // 每 5 分钟检查一次 Token 有效性
     const checkInterval = 5 * 60 * 1000;
     
     setInterval(async () => {
       try {
         // 发送请求验证 Token
         await axios.get('/api/auth/verify-token');
         // Token 有效，无需处理
       } catch (error) {
         // Token 无效，尝试刷新或重定向到登录页
         if (error.response?.status === 401) {
           try {
             const refreshToken = localStorage.getItem('refreshToken');
             if (!refreshToken) {
               redirectToLogin();
               return;
             }
             
             const response = await axios.post('/api/auth/refresh-token', {
               refreshToken
             });
             
             // 更新存储的 Token
             const { token, refreshToken: newRefreshToken } = response.data;
             localStorage.setItem('token', token);
             localStorage.setItem('refreshToken', newRefreshToken);
             
             // 更新请求头
             axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
           } catch (refreshError) {
             redirectToLogin();
           }
         }
       }
     }, checkInterval);
   }
   ```

## 3. 权限问题

### 3.1 权限配置问题

#### 3.1.1 问题描述

管理员无法正确配置用户或角色的权限，或权限配置后不生效。

#### 3.1.2 可能原因

1. 权限数据结构不正确
2. 权限保存接口异常
3. 权限缓存未更新
4. 前端权限组件渲染问题

#### 3.1.3 解决方案

1. **检查权限数据结构**

   ```javascript
   // 正确的权限数据结构示例
   const permissionData = {
     roleId: 'editor',
     permissions: [
       'news:view',
       'news:create',
       'news:edit',
       'news:submit',
       'category:view'
     ]
   };
   
   // 验证权限数据结构
   function validatePermissionData(data) {
     if (!data.roleId || typeof data.roleId !== 'string') {
       console.error('角色ID无效');
       return false;
     }
     
     if (!Array.isArray(data.permissions)) {
       console.error('权限数组无效');
       return false;
     }
     
     // 检查权限格式是否正确
     const validFormat = data.permissions.every(perm => {
       return typeof perm === 'string' && /^[a-z]+:[a-z]+$/.test(perm);
     });
     
     if (!validFormat) {
       console.error('权限格式不正确，应为 resource:action 格式');
       return false;
     }
     
     return true;
   }
   ```

2. **权限保存接口调试**

   ```javascript
   // 保存角色权限
   async function saveRolePermissions(roleId, permissions) {
     try {
       // 打印请求数据用于调试
       console.log('保存权限请求数据:', { roleId, permissions });
       
       const response = await axios.post('/api/roles/permissions', {
         roleId,
         permissions
       });
       
       console.log('保存权限响应:', response.data);
       
       if (response.data.success) {
         message.success('权限配置已保存');
         return true;
       } else {
         message.error(`保存失败: ${response.data.message}`);
         return false;
       }
     } catch (error) {
       console.error('保存权限出错:', error.response?.data || error.message);
       message.error('保存权限失败，请检查网络连接或联系管理员');
       return false;
     }
   }
   ```

3. **清除权限缓存**

   ```javascript
   // 清除权限缓存并通知用户重新登录
   async function clearPermissionCache(roleId) {
     try {
       const response = await axios.post('/api/system/clear-permission-cache', {
         roleId
       });
       
       if (response.data.success) {
         message.success('权限缓存已清除，用户下次登录时将获取新权限');
         return true;
       } else {
         message.warning(`清除缓存失败: ${response.data.message}`);
         return false;
       }
     } catch (error) {
       console.error('清除权限缓存出错:', error);
       message.error('清除权限缓存失败');
       return false;
     }
   }
   ```

4. **修复权限组件渲染**

   ```javascript
   // 权限树组件渲染问题修复
   function PermissionTree({ permissions, checkedKeys, onCheck }) {
     // 确保数据有效
     const validPermissions = Array.isArray(permissions) ? permissions : [];
     const validCheckedKeys = Array.isArray(checkedKeys) ? checkedKeys : [];
     
     // 转换权限数据为树形结构
     const permissionTree = useMemo(() => {
       const tree = [];
       const moduleMap = {};
       
       validPermissions.forEach(perm => {
         // 分割权限代码，如 'news:create' => ['news', 'create']
         const [module, action] = perm.split(':');
         
         if (!module || !action) return;
         
         if (!moduleMap[module]) {
           // 创建模块节点
           const moduleNode = {
             key: module,
             title: getModuleTitle(module),
             children: []
           };
           tree.push(moduleNode);
           moduleMap[module] = moduleNode;
         }
         
         // 添加操作节点
         moduleMap[module].children.push({
           key: `${module}:${action}`,
           title: getActionTitle(action)
         });
       });
       
       return tree;
     }, [validPermissions]);
     
     // 获取模块显示名称
     function getModuleTitle(module) {
       const moduleNames = {
         news: '新闻管理',
         category: '分类管理',
         user: '用户管理',
         role: '角色管理',
         system: '系统管理'
       };
       return moduleNames[module] || module;
     }
     
     // 获取操作显示名称
     function getActionTitle(action) {
       const actionNames = {
         view: '查看',
         create: '创建',
         edit: '编辑',
         delete: '删除',
         publish: '发布',
         submit: '提交',
         approve: '审核',
         reject: '驳回'
       };
       return actionNames[action] || action;
     }
     
     // 处理空数据情况
     if (permissionTree.length === 0) {
       return <Empty description="暂无权限数据" />;
     }
     
     return (
       <Tree
         checkable
         defaultExpandAll
         checkedKeys={validCheckedKeys}
         onCheck={onCheck}
         treeData={permissionTree}
       />
     );
   }
   ```

### 3.2 动态路由问题

#### 3.2.1 问题描述

基于权限的动态路由生成失败，导致用户无法访问应有的页面，或页面显示异常。

#### 3.2.2 可能原因

1. 路由配置与权限不匹配
2. 动态路由生成逻辑错误
3. 路由组件加载失败

#### 3.2.3 解决方案

1. **检查路由与权限映射**

   ```javascript
   // 路由与权限映射配置
   const routePermissionMap = {
     '/news': 'news:view',
     '/news/create': 'news:create',
     '/news/edit': 'news:edit',
     '/category': 'category:view',
     '/user': 'user:view',
     '/role': 'role:view',
     '/system': 'system:view'
   };
   
   // 检查路由权限映射是否完整
   function validateRoutePermissionMap() {
     const allRoutes = Object.keys(routePermissionMap);
     const allPermissions = Object.values(routePermissionMap);
     
     console.log('所有路由:', allRoutes);
     console.log('所有权限:', allPermissions);
     
     // 检查是否有重复的权限
     const uniquePermissions = new Set(allPermissions);
     if (uniquePermissions.size !== allPermissions.length) {
       console.warn('存在重复的权限配置');
     }
     
     // 检查是否有未映射的路由
     const routeComponents = [
       '/news',
       '/news/create',
       '/news/edit',
       '/category',
       '/user',
       '/role',
       '/system'
     ];
     
     const unmappedRoutes = routeComponents.filter(route => !allRoutes.includes(route));
     if (unmappedRoutes.length > 0) {
       console.warn('存在未映射权限的路由:', unmappedRoutes);
     }
   }
   ```

2. **修复动态路由生成逻辑**

   ```javascript
   // 根据用户权限生成动态路由
   function generateRoutes(userPermissions) {
     // 确保权限数据有效
     if (!Array.isArray(userPermissions)) {
       console.error('用户权限数据无效');
       return [];
     }
     
     // 所有可用路由配置
     const allRoutes = [
       {
         path: '/news',
         component: NewsListPage,
         permission: 'news:view',
         children: [
           {
             path: '/news/create',
             component: NewsCreatePage,
             permission: 'news:create'
           },
           {
             path: '/news/edit/:id',
             component: NewsEditPage,
             permission: 'news:edit'
           }
         ]
       },
       {
         path: '/category',
         component: CategoryPage,
         permission: 'category:view'
       },
       {
         path: '/user',
         component: UserPage,
         permission: 'user:view'
       },
       {
         path: '/role',
         component: RolePage,
         permission: 'role:view'
       },
       {
         path: '/system',
         component: SystemPage,
         permission: 'system:view'
       }
     ];
     
     // 过滤出用户有权限的路由
     function filterRoutesByPermission(routes, permissions) {
       return routes
         .filter(route => {
           // 无权限要求或有对应权限
           return !route.permission || permissions.includes(route.permission);
         })
         .map(route => {
           // 处理子路由
           const newRoute = { ...route };
           if (route.children && route.children.length > 0) {
             newRoute.children = filterRoutesByPermission(route.children, permissions);
           }
           return newRoute;
         });
     }
     
     // 生成用户可访问的路由
     const accessibleRoutes = filterRoutesByPermission(allRoutes, userPermissions);
     console.log('用户可访问路由:', accessibleRoutes);
     
     return accessibleRoutes;
   }
   ```

3. **处理路由组件加载失败**

   ```javascript
   // 路由组件错误边界
   class RouteErrorBoundary extends React.Component {
     constructor(props) {
       super(props);
       this.state = { hasError: false, error: null };
     }
     
     static getDerivedStateFromError(error) {
       return { hasError: true, error };
     }
     
     componentDidCatch(error, errorInfo) {
       console.error('路由组件加载失败:', error, errorInfo);
       // 可以将错误信息发送到日志服务
     }
     
     render() {
       if (this.state.hasError) {
         return (
           <div className="route-error">
             <h2>页面加载失败</h2>
             <p>抱歉，页面加载过程中出现错误。</p>
             <p>错误信息: {this.state.error?.message}</p>
             <Button type="primary" onClick={() => this.setState({ hasError: false })}>
               重试
             </Button>
             <Button onClick={() => window.location.href = '/'}>
               返回首页
             </Button>
           </div>
         );
       }
       
       return this.props.children;
     }
   }
   
   // 使用懒加载和错误边界包装路由组件
   const lazyLoadComponent = (importFunc) => {
     const LazyComponent = React.lazy(importFunc);
     return (props) => (
       <RouteErrorBoundary>
         <React.Suspense fallback={<div>加载中...</div>}>
           <LazyComponent {...props} />
         </React.Suspense>
       </RouteErrorBoundary>
     );
   };
   
   // 使用示例
   const NewsListPage = lazyLoadComponent(() => import('./pages/news/NewsList'));
   const NewsCreatePage = lazyLoadComponent(() => import('./pages/news/NewsCreate'));
   ```

## 4. 新闻管理问题

### 4.1 新闻创建与编辑问题

#### 4.1.1 问题描述

创建或编辑新闻时遇到表单提交失败、内容丢失或格式错误等问题。

#### 4.1.2 可能原因

1. 表单验证规则不正确
2. 富文本编辑器内容处理错误
3. 图片上传失败
4. 请求数据格式错误

#### 4.1.3 解决方案

1. **修复表单验证**

   ```javascript
   // 新闻表单验证规则
   const newsFormRules = {
     title: [
       { required: true, message: '请输入新闻标题' },
       { max: 100, message: '标题不能超过100个字符' }
     ],
     categoryId: [
       { required: true, message: '请选择新闻分类' }
     ],
     content: [
       { required: true, message: '请输入新闻内容' },
       { validator: validateContent }
     ],
     summary: [
       { max: 200, message: '摘要不能超过200个字符' }
     ],
     tags: [
       { validator: validateTags }
     ],
     publishTime: [
       { required: false }
     ]
   };
   
   // 自定义内容验证
   function validateContent(_, value) {
     if (!value || value === '<p></p>') {
       return Promise.reject('新闻内容不能为空');
     }
     
     // 检查内容长度（去除HTML标签后）
     const textContent = value.replace(/<[^>]+>/g, '');
     if (textContent.length < 10) {
       return Promise.reject('新闻内容太短，至少需要10个字符');
     }
     
     return Promise.resolve();
   }
   
   // 自定义标签验证
   function validateTags(_, value) {
     if (!value) {
       return Promise.resolve();
     }
     
     if (!Array.isArray(value)) {
       return Promise.reject('标签格式不正确');
     }
     
     if (value.length > 5) {
       return Promise.reject('标签不能超过5个');
     }
     
     // 检查每个标签的长度
     const invalidTags = value.filter(tag => tag.length > 20);
     if (invalidTags.length > 0) {
       return Promise.reject('单个标签不能超过20个字符');
     }
     
     return Promise.resolve();
   }
   ```

2. **富文本编辑器内容处理**

   ```javascript
   // 富文本编辑器内容处理
   function handleEditorContent(content) {
     if (!content) {
       return '';
     }
     
     // 清理不安全的HTML标签和属性
     let safeContent = DOMPurify.sanitize(content, {
       ALLOWED_TAGS: [
         'p', 'br', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
         'blockquote', 'ul', 'ol', 'li', 'strong', 'em',
         'a', 'img', 'table', 'thead', 'tbody', 'tr', 'th', 'td',
         'hr', 'pre', 'code'
       ],
       ALLOWED_ATTR: [
         'href', 'target', 'src', 'alt', 'width', 'height',
         'style', 'class'
       ]
     });
     
     // 修复相对路径的图片链接
     safeContent = safeContent.replace(/src="\/uploads\//g, `src="${process.env.REACT_APP_API_URL}/uploads/`);
     
     return safeContent;
   }
   
   // 在表单提交前处理富文本内容
   function handleSubmit(values) {
     // 处理富文本内容
     const processedContent = handleEditorContent(values.content);
     
     // 更新表单数据
     const formData = {
       ...values,
       content: processedContent
     };
     
     // 提交表单
     submitNews(formData);
   }
   ```

3. **图片上传问题修复**

   ```javascript
   // 图片上传组件
   function ImageUploader({ value, onChange }) {
     const [fileList, setFileList] = useState([]);
     const [uploading, setUploading] = useState(false);
     const [error, setError] = useState('');
     
     // 初始化已有图片
     useEffect(() => {
       if (value && typeof value === 'string') {
         setFileList([{
           uid: '-1',
           name: 'image.png',
           status: 'done',
           url: value
         }]);
       }
     }, []);
     
     // 处理图片上传前的验证
     const beforeUpload = (file) => {
       setError('');
       
       // 检查文件类型
       const isImage = file.type.startsWith('image/');
       if (!isImage) {
         setError('只能上传图片文件!');
         return Upload.LIST_IGNORE;
       }
       
       // 检查文件大小（2MB限制）
       const isLessThan2M = file.size / 1024 / 1024 < 2;
       if (!isLessThan2M) {
         setError('图片必须小于2MB!');
         return Upload.LIST_IGNORE;
       }
       
       return true;
     };
     
     // 自定义上传方法
     const customUpload = async ({ file, onSuccess, onError }) => {
       setUploading(true);
       
       try {
         const formData = new FormData();
         formData.append('image', file);
         
         const response = await axios.post('/api/upload/image', formData, {
           headers: {
             'Content-Type': 'multipart/form-data'
           }
         });
         
         if (response.data && response.data.url) {
           // 上传成功
           onSuccess(response, file);
           
           // 更新表单值
           onChange(response.data.url);
           
           // 更新文件列表
           setFileList([{
             uid: file.uid,
             name: file.name,
             status: 'done',
             url: response.data.url
           }]);
         } else {
           onError(new Error('上传失败'));
           setError('上传失败，请重试');
         }
       } catch (error) {
         console.error('图片上传错误:', error);
         onError(error);
         setError(`上传失败: ${error.message}`);
       } finally {
         setUploading(false);
       }
     };
     
     // 处理文件列表变化
     const handleChange = ({ fileList: newFileList }) => {
       setFileList(newFileList);
       
       // 如果文件列表为空，清除表单值
       if (newFileList.length === 0) {
         onChange(undefined);
       }
     };
     
     return (
       <div className="image-uploader">
         <Upload
           listType="picture-card"
           fileList={fileList}
           beforeUpload={beforeUpload}
           customRequest={customUpload}
           onChange={handleChange}
           maxCount={1}
         >
           {fileList.length === 0 && (
             <div>
               {uploading ? <LoadingOutlined /> : <PlusOutlined />}
               <div style={{ marginTop: 8 }}>上传</div>
             </div>
           )}
         </Upload>
         {error && <div className="upload-error">{error}</div>}
       </div>
     );
   }
   ```

4. **请求数据格式修复**

   ```javascript
   // 提交新闻数据
   async function submitNews(newsData) {
     try {
       // 格式化数据
       const formattedData = {
         ...newsData,
         // 确保分类ID是字符串
         categoryId: String(newsData.categoryId),
         // 确保标签是数组
         tags: Array.isArray(newsData.tags) ? newsData.tags : [],
         // 格式化发布时间
         publishTime: newsData.publishTime ? moment(newsData.publishTime).format('YYYY-MM-DD HH:mm:ss') : null
       };
       
       console.log('提交的新闻数据:', formattedData);
       
       // 发送请求
       let response;
       if (formattedData.id) {
         // 更新现有新闻
         response = await axios.put(`/api/news/${formattedData.id}`, formattedData);
       } else {
         // 创建新新闻
         response = await axios.post('/api/news', formattedData);
       }
       
       if (response.data.success) {
         message.success(formattedData.id ? '新闻更新成功' : '新闻创建成功');
         return response.data.data;
       } else {
         message.error(`操作失败: ${response.data.message}`);
         return null;
       }
     } catch (error) {
       console.error('提交新闻失败:', error.response?.data || error.message);
       
       // 处理特定错误
       if (error.response?.status === 413) {
         message.error('内容过大，请减少图片数量或压缩图片');
       } else if (error.response?.status === 422) {
         message.error('数据验证失败，请检查表单内容');
       } else {
         message.error('操作失败，请稍后重试');
       }
       
       return null;
     }
   }
   ```

### 4.2 新闻审核与发布问题

#### 4.2.1 问题描述

新闻审核或发布流程中出现状态更新失败、权限错误或工作流异常等问题。

#### 4.2.2 可能原因

1. 状态转换逻辑错误
2. 审核权限验证失败
3. 发布时间设置错误
4. 工作流程配置问题

#### 4.2.3 解决方案

1. **修复状态转换逻辑**

   ```javascript
   // 新闻状态常量
   const NEWS_STATUS = {
     // 审核状态
     DRAFT: 0,        // 草稿
     PENDING: 1,      // 审核中
     APPROVED: 2,     // 已通过
     REJECTED: 3,     // 已驳回
     
     // 发布状态
     UNPUBLISHED: 0,  // 未发布
     SCHEDULED: 1,    // 待发布
     PUBLISHED: 2,    // 已发布
     OFFLINE: 3       // 已下线
   };
   
   // 状态转换验证
   function validateStatusTransition(currentStatus, newStatus, userRole) {
     // 审核状态转换规则
     const auditStatusRules = {
       [NEWS_STATUS.DRAFT]: [NEWS_STATUS.PENDING],  // 草稿 -> 审核中
       [NEWS_STATUS.PENDING]: [NEWS_STATUS.APPROVED, NEWS_STATUS.REJECTED],  // 审核中 -> 已通过/已驳回
       [NEWS_STATUS.APPROVED]: [],  // 已通过 -> 不能直接改变审核状态
       [NEWS_STATUS.REJECTED]: [NEWS_STATUS.DRAFT]  // 已驳回 -> 草稿
     };
     
     // 发布状态转换规则
     const publishStatusRules = {
       [NEWS_STATUS.UNPUBLISHED]: [NEWS_STATUS.SCHEDULED, NEWS_STATUS.PUBLISHED],  // 未发布 -> 待发布/已发布
       [NEWS_STATUS.SCHEDULED]: [NEWS_STATUS.PUBLISHED, NEWS_STATUS.UNPUBLISHED],  // 待发布 -> 已发布/未发布
       [NEWS_STATUS.PUBLISHED]: [NEWS_STATUS.OFFLINE],  // 已发布 -> 已下线
       [NEWS_STATUS.OFFLINE]: [NEWS_STATUS.PUBLISHED, NEWS_STATUS.UNPUBLISHED]  // 已下线 -> 已发布/未发布
     };
     
     // 根据操作类型选择规则
     let rules;
     let statusType;
     
     if ('auditStatus' in newStatus) {
       rules = auditStatusRules;
       statusType = 'auditStatus';
     } else if ('publishStatus' in newStatus) {
       rules = publishStatusRules;
       statusType = 'publishStatus';
     } else {
       console.error('未知的状态类型');
       return false;
     }
     
     // 检查状态转换是否有效
     const currentVal = currentStatus[statusType];
     const newVal = newStatus[statusType];
     
     if (!rules[currentVal] || !rules[currentVal].includes(newVal)) {
       console.error(`无效的状态转换: ${currentVal} -> ${newVal}`);
       return false;
     }
     
     // 检查用户角色权限
     if (statusType === 'auditStatus' && newVal === NEWS_STATUS.APPROVED && userRole !== 'admin' && userRole !== 'auditor') {
       console.error('只有管理员或审核员可以审核通过新闻');
       return false;
     }
     
     if (statusType === 'publishStatus' && (newVal === NEWS_STATUS.PUBLISHED || newVal === NEWS_STATUS.SCHEDULED) && userRole !== 'admin' && userRole !== 'publisher') {
       console.error('只有管理员或发布员可以发布新闻');
       return false;
     }
     
     return true;
   }
   ```

2. **审核权限验证**

   ```javascript
   // 审核权限检查
   function checkAuditPermission(news, action, user) {
     // 检查用户是否存在
     if (!user || !user.role) {
       console.error('用户信息不完整');
       return false;
     }
     
     // 超级管理员拥有所有权限
     if (user.role === 'superadmin') {
       return true;
     }
     
     // 检查特定操作权限
     switch (action) {
       case 'submit':
         // 提交审核：作者或编辑可以提交
         return news.createdBy === user.id || user.role === 'editor' || user.permissions.includes('news:submit');
         
       case 'approve':
         // 审核通过：需要审核员或管理员权限
         return user.role === 'auditor' || user.role === 'admin' || user.permissions.includes('news:approve');
         
       case 'reject':
         // 驳回：需要审核员或管理员权限
         return user.role === 'auditor' || user.role === 'admin' || user.permissions.includes('news:reject');
         
       case 'publish':
         // 发布：需要发布员或管理员权限，且新闻必须已审核通过
         return (user.role === 'publisher' || user.role === 'admin' || user.permissions.includes('news:publish')) && 
                news.auditStatus === NEWS_STATUS.APPROVED;
                
       case 'offline':
         // 下线：需要发布员或管理员权限
         return user.role === 'publisher' || user.role === 'admin' || user.permissions.includes('news:offline');
         
       default:
         console.error('未知的操作类型:', action);
         return false;
     }
   }
   ```

3. **发布时间设置修复**

   ```javascript
   // 处理发布时间设置
   function handlePublishTimeChange(value, form) {
     // 获取当前表单值
     const currentValues = form.getFieldsValue();
     
     if (value) {
       // 有设置发布时间
       const publishTime = moment(value);
       const now = moment();
       
       // 检查发布时间是否在未来
       if (publishTime.isAfter(now)) {
         // 未来时间，设置为待发布状态
         form.setFieldsValue({
           ...currentValues,
           publishStatus: NEWS_STATUS.SCHEDULED
         });
       } else {
         // 当前或过去时间，设置为已发布状态
         form.setFieldsValue({
           ...currentValues,
           publishStatus: NEWS_STATUS.PUBLISHED
         });
       }
     } else {
       // 未设置发布时间，设置为未发布状态
       form.setFieldsValue({
         ...currentValues,
         publishStatus: NEWS_STATUS.UNPUBLISHED
       });
     }
   }
   
   // 发布时间组件
   function PublishTimePicker({ value, onChange, form }) {
     // 处理时间变化
     const handleChange = (time) => {
       onChange(time);
       handlePublishTimeChange(time, form);
     };
     
     return (
       <DatePicker
         showTime
         format="YYYY-MM-DD HH:mm:ss"
         value={value ? moment(value) : null}
         onChange={handleChange}
         placeholder="选择发布时间"
         style={{ width: '100%' }}
       />
     );
   }
   ```

4. **工作流程配置修复**

   ```javascript
   // 新闻工作流配置
   const newsWorkflow = {
     // 初始状态
     initialState: {
       auditStatus: NEWS_STATUS.DRAFT,
       publishStatus: NEWS_STATUS.UNPUBLISHED
     },
     
     // 状态转换定义
     transitions: [
       {
         name: 'submitForReview',
         from: { auditStatus: NEWS_STATUS.DRAFT },
         to: { auditStatus: NEWS_STATUS.PENDING },
         conditions: ['isComplete', 'isAuthorOrEditor'],
         actions: ['notifyAuditors', 'logActivity']
       },
       {
         name: 'approve',
         from: { auditStatus: NEWS_STATUS.PENDING },
         to: { auditStatus: NEWS_STATUS.APPROVED },
         conditions: ['isAuditorOrAdmin'],
         actions: ['notifyAuthor', 'notifyPublishers', 'logActivity']
       },
       {
         name: 'reject',
         from: { auditStatus: NEWS_STATUS.PENDING },
         to: { auditStatus: NEWS_STATUS.REJECTED },
         conditions: ['isAuditorOrAdmin', 'hasRejectReason'],
         actions: ['notifyAuthor', 'logActivity']
       },
       {
         name: 'revise',
         from: { auditStatus: NEWS_STATUS.REJECTED },
         to: { auditStatus: NEWS_STATUS.DRAFT },
         conditions: ['isAuthorOrEditor'],
         actions: ['logActivity']
       },
       {
         name: 'publish',
         from: { 
           auditStatus: NEWS_STATUS.APPROVED,
           publishStatus: [NEWS_STATUS.UNPUBLISHED, NEWS_STATUS.SCHEDULED, NEWS_STATUS.OFFLINE]
         },
         to: { publishStatus: NEWS_STATUS.PUBLISHED },
         conditions: ['isPublisherOrAdmin'],
         actions: ['setPublishTime', 'notifyAuthor', 'logActivity']
       },
       {
         name: 'schedule',
         from: { 
           auditStatus: NEWS_STATUS.APPROVED,
           publishStatus: [NEWS_STATUS.UNPUBLISHED, NEWS_STATUS.OFFLINE]
         },
         to: { publishStatus: NEWS_STATUS.SCHEDULED },
         conditions: ['isPublisherOrAdmin', 'hasFuturePublishTime'],
         actions: ['logActivity']
       },
       {
         name: 'takeOffline',
         from: { publishStatus: NEWS_STATUS.PUBLISHED },
         to: { publishStatus: NEWS_STATUS.OFFLINE },
         conditions: ['isPublisherOrAdmin'],
         actions: ['logActivity']
       },
       {
         name: 'cancelSchedule',
         from: { publishStatus: NEWS_STATUS.SCHEDULED },
         to: { publishStatus: NEWS_STATUS.UNPUBLISHED },
         conditions: ['isPublisherOrAdmin'],
         actions: ['clearPublishTime', 'logActivity']
       }
     ],
     
     // 条件检查函数
     conditions: {
       isComplete: (news) => {
         return news.title && news.content && news.categoryId;
       },
       isAuthorOrEditor: (news, user) => {
         return news.createdBy === user.id || user.role === 'editor' || user.permissions.includes('news:edit');
       },
       isAuditorOrAdmin: (news, user) => {
         return user.role === 'auditor' || user.role === 'admin' || user.permissions.includes('news:approve');
       },
       isPublisherOrAdmin: (news, user) => {
         return user.role === 'publisher' || user.role === 'admin' || user.permissions.includes('news:publish');
       },
       hasRejectReason: (news) => {
         return news.rejectReason && news.rejectReason.trim().length > 0;
       },
       hasFuturePublishTime: (news) => {
         return news.publishTime && moment(news.publishTime).isAfter(moment());
       }
     },
     
     // 动作执行函数
     actions: {
       notifyAuditors: async (news) => {
         try {
           await axios.post('/api/notifications/auditors', {
             newsId: news.id,
             title: news.title,
             message: `新闻《${news.title}》已提交审核，请及时处理`
           });
         } catch (error) {
           console.error('通知审核员失败:', error);
         }
       },
       notifyAuthor: async (news, transition) => {
         try {
           let message = '';
           if (transition === 'approve') {
             message = `您的新闻《${news.title}》已审核通过`;
           } else if (transition === 'reject') {
             message = `您的新闻《${news.title}》被驳回，原因: ${news.rejectReason}`;
           } else if (transition === 'publish') {
             message = `您的新闻《${news.title}》已发布`;
           }
           
           await axios.post('/api/notifications/author', {
             userId: news.createdBy,
             newsId: news.id,
             title: news.title,
             message
           });
         } catch (error) {
           console.error('通知作者失败:', error);
         }
       },
       notifyPublishers: async (news) => {
         try {
           await axios.post('/api/notifications/publishers', {
             newsId: news.id,
             title: news.title,
             message: `新闻《${news.title}》已审核通过，可以安排发布`
           });
         } catch (error) {
           console.error('通知发布员失败:', error);
         }
       },
       setPublishTime: (news) => {
         // 如果没有设置发布时间，则设置为当前时间
         if (!news.publishTime) {
           news.publishTime = new Date().toISOString();
         }
       },
       clearPublishTime: (news) => {
         news.publishTime = null;
       },
       logActivity: async (news, transition, user) => {
         try {
           await axios.post('/api/logs/news-activity', {
             newsId: news.id,
             userId: user.id,
             action: transition,
             timestamp: new Date().toISOString(),
             details: {
               title: news.title,
               auditStatus: news.auditStatus,
               publishStatus: news.publishStatus
             }
           });
         } catch (error) {
           console.error('记录活动日志失败:', error);
         }
       }
     }
   };
   
   // 执行工作流转换
   async function executeWorkflowTransition(news, transitionName, user, additionalData = {}) {
     try {
       // 查找转换定义
       const transition = newsWorkflow.transitions.find(t => t.name === transitionName);
       if (!transition) {
         throw new Error(`未找到转换定义: ${transitionName}`);
       }
       
       // 检查当前状态是否满足转换条件
       const fromMatches = Object.entries(transition.from).every(([key, value]) => {
         if (Array.isArray(value)) {
           return value.includes(news[key]);
         }
         return news[key] === value;
       });
       
       if (!fromMatches) {
         throw new Error(`当前状态不满足转换条件: ${JSON.stringify(news)} -> ${transitionName}`);
       }
       
       // 合并附加数据
       const updatedNews = { ...news, ...additionalData };
       
       // 检查条件
       for (const conditionName of transition.conditions) {
         const conditionFn = newsWorkflow.conditions[conditionName];
         if (!conditionFn(updatedNews, user)) {
           throw new Error(`条件不满足: ${conditionName}`);
         }
       }
       
       // 应用状态变更
       const result = { ...updatedNews, ...transition.to };
       
       // 执行动作
       for (const actionName of transition.actions) {
         const actionFn = newsWorkflow.actions[actionName];
         await actionFn(result, transitionName, user);
       }
       
       // 保存更新后的新闻
       const response = await axios.put(`/api/news/${news.id}`, result);
       
       if (response.data.success) {
         message.success(`操作成功: ${getTransitionDisplayName(transitionName)}`);
         return response.data.data;
       } else {
         throw new Error(response.data.message || '保存失败');
       }
     } catch (error) {
       console.error(`执行工作流转换失败 (${transitionName}):`, error);
       message.error(`操作失败: ${error.message}`);
       return null;
     }
   }
   
   // 获取转换显示名称
   function getTransitionDisplayName(transitionName) {
     const nameMap = {
       submitForReview: '提交审核',
       approve: '审核通过',
       reject: '驳回',
       revise: '修改',
       publish: '发布',
       schedule: '定时发布',
       takeOffline: '下线',
       cancelSchedule: '取消定时发布'
     };
     
     return nameMap[transitionName] || transitionName;
   }
   ```

## 5. 富文本编辑器问题

### 5.1 内容渲染问题

#### 5.1.1 问题描述

富文本编辑器内容在编辑、保存或显示时出现格式丢失、图片显示异常或样式错乱等问题。

#### 5.1.2 可能原因

1. 编辑器配置不正确
2. HTML 内容清理过滤问题
3. 图片上传和引用路径问题
4. CSS 样式冲突

#### 5.1.3 解决方案

1. **编辑器配置优化**

   ```javascript
   // 富文本编辑器配置
   function configureEditor(editor) {
     // 工具栏配置
     editor.config.toolbar = [
       'head',
       'bold',
       'fontSize',
       'fontName',
       'italic',
       'underline',
       'strikeThrough',
       'indent',
       'lineHeight',
       'foreColor',
       'backColor',
       'link',
       'list',
       'todo',
       'justify',
       'quote',
       'emoticon',
       'image',
       'table',
       'code',
       'splitLine',
       'undo',
       'redo',
     ];
     
     // 图片上传配置
     editor.config.uploadImgServer = '/api/upload/image';
     editor.config.uploadImgMaxSize = 2 * 1024 * 1024; // 2MB
     editor.config.uploadImgMaxLength = 5; // 一次最多上传 5 张图片
     editor.config.uploadFileName = 'image';
     editor.config.uploadImgHeaders = {
       Authorization: `Bearer ${localStorage.getItem('token')}`
     };
     editor.config.uploadImgHooks = {
       // 上传图片之前
       before: function(xhr) {
         console.log('准备上传图片');
       },
       // 图片上传并返回了结果，但图片插入编辑器之前
       success: function(xhr) {
         console.log('图片上传成功');
       },
       // 图片上传并返回了结果，图片插入已成功
       fail: function(xhr, editor, resData) {
         console.error('图片上传失败', resData);
         message.error(`图片上传失败: ${resData.message || '未知错误'}`);
       },
       // 图片上传并返回了结果，但图片插入时出错了
       error: function(xhr, editor, resData) {
         console.error('图片插入错误', resData);
         message.error('图片插入错误，请重试');
       },
       // 图片上传并返回了结果，图片已插入编辑器
       timeout: function(xhr) {
         message.error('图片上传超时，请重试');
       },
       // 图片上传并返回了结果，想要自己处理图片插入
       customInsert: function(insertImgFn, result) {
         if (result.errno === 0 && result.data && result.data.url) {
           insertImgFn(result.data.url);
         } else {
           message.error('图片插入失败，请重试');
         }
       }
     };
     
     // 内容样式配置
     editor.config.zIndex = 1;
     editor.config.placeholder = '请输入内容...';
     editor.config.fontSize = ['12px', '14px', '16px', '18px', '20px', '24px', '36px'];
     editor.config.lineHeights = ['1', '1.5', '1.75', '2', '2.5', '3'];
     
     // 粘贴内容过滤配置
     editor.config.pasteFilterStyle = false;
     editor.config.pasteIgnoreImg = false;
     editor.config.pasteTextHandle = function(content) {
       // 对粘贴的文本进行处理
       return content;
     };
     
     return editor;
   }
   ```

2. **HTML 内容清理**

   ```javascript
   // HTML 内容清理函数
   function sanitizeHtml(html) {
     if (!html) return '';
     
     // 使用 DOMPurify 清理 HTML
     const clean = DOMPurify.sanitize(html, {
       ALLOWED_TAGS: [
         'p', 'br', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
         'blockquote', 'ul', 'ol', 'li', 'strong', 'em',
         'a', 'img', 'table', 'thead', 'tbody', 'tr', 'th', 'td',
         'hr', 'pre', 'code', 'span', 'div'
       ],
       ALLOWED_ATTR: [
         'href', 'target', 'src', 'alt', 'width', 'height',
         'style', 'class', 'id', 'title', 'rel'
       ],
       ALLOW_DATA_ATTR: false,
       USE_PROFILES: { html: true }
     });
     
     return clean;
   }
   
   // 在保存前清理内容
   function prepareContentForSave(content) {
     // 清理 HTML
     let cleanContent = sanitizeHtml(content);
     
     // 处理图片路径，确保使用绝对路径
     cleanContent = cleanContent.replace(/src="\/uploads\//g, `src="${process.env.REACT_APP_API_URL}/uploads/`);
     
     // 处理空内容
     if (cleanContent === '<p></p>' || cleanContent === '<p><br></p>') {
       return '';
     }
     
     return cleanContent;
   }
   
   // 在显示前准备内容
   function prepareContentForDisplay(content) {
     if (!content) return '';
     
     // 清理 HTML
     let cleanContent = sanitizeHtml(content);
     
     // 确保图片路径正确
     cleanContent = cleanContent.replace(/src="\/uploads\//g, `src="${process.env.REACT_APP_API_URL}/uploads/`);
     
     return cleanContent;
   }
   ```

3. **图片路径处理**

   ```javascript
   // 图片上传处理
   async function uploadImage(file) {
     try {
       // 检查文件类型
       const isImage = file.type.startsWith('image/');
       if (!isImage) {
         message.error('只能上传图片文件!');
         return null;
       }
       
       // 检查文件大小（2MB限制）
       const isLessThan2M = file.size / 1024 / 1024 < 2;
       if (!isLessThan2M) {
         message.error('图片必须小于2MB!');
         return null;
       }
       
       // 创建表单数据
       const formData = new FormData();
       formData.append('image', file);
       
       // 发送上传请求
       const response = await axios.post('/api/upload/image', formData, {
         headers: {
           'Content-Type': 'multipart/form-data',
           'Authorization': `Bearer ${localStorage.getItem('token')}`
         }
       });
       
       if (response.data && response.data.url) {
         // 返回完整的图片URL
         return response.data.url.startsWith('http') 
           ? response.data.url 
           : `${process.env.REACT_APP_API_URL}${response.data.url}`;
       } else {
         message.error('图片上传失败');
         return null;
       }
     } catch (error) {
       console.error('图片上传错误:', error);
       message.error(`上传失败: ${error.message}`);
       return null;
     }
   }
   
   // 修复编辑器中的图片路径
   function fixImagePaths(editor) {
     // 获取编辑器内容
     const content = editor.txt.html();
     
     // 修复图片路径
     const fixedContent = content.replace(/src="\/uploads\//g, `src="${process.env.REACT_APP_API_URL}/uploads/`);
     
     // 设置修复后的内容
     if (content !== fixedContent) {
       editor.txt.html(fixedContent);
     }
   }
   ```

4. **CSS 样式冲突解决**

   ```javascript
   // 编辑器样式隔离
   function EditorWithIsolatedStyles({ value, onChange }) {
     const editorRef = useRef(null);
     const [editor, setEditor] = useState(null);
     
     // 初始化编辑器
     useEffect(() => {
       if (!editorRef.current) return;
       
       // 创建编辑器实例
       const newEditor = new E(editorRef.current);
       
       // 配置编辑器
       configureEditor(newEditor);
       
       // 创建编辑器
       newEditor.create();
       
       // 设置初始内容
       if (value) {
         newEditor.txt.html(value);
       }
       
       // 监听内容变化
       newEditor.config.onchange = function(html) {
         if (onChange) {
           onChange(html);
         }
       };
       
       // 保存编辑器实例
       setEditor(newEditor);
       
       // 组件卸载时销毁编辑器
       return () => {
         if (newEditor) {
           newEditor.destroy();
         }
       };
     }, []);
     
     // 当外部 value 变化时更新编辑器内容
     useEffect(() => {
       if (editor && value !== undefined && value !== editor.txt.html()) {
         editor.txt.html(value);
       }
     }, [value, editor]);
     
     return (
       <div className="editor-container">
         {/* 编辑器容器 */}
         <div ref={editorRef} className="editor-wrapper"></div>
         
         {/* 隔离的编辑器样式 */}
         <style jsx>{`
           .editor-container {
             border: 1px solid #d9d9d9;
             border-radius: 4px;
             overflow: hidden;
           }
           
           .editor-container :global(.w-e-toolbar) {
             border-bottom: 1px solid #f0f0f0;
             background-color: #fafafa;
           }
           
           .editor-container :global(.w-e-text-container) {
             height: 300px !important;
           }
           
           /* 防止样式冲突 */
           .editor-container :global(*) {
             box-sizing: border-box;
           }
           
           /* 修复图片显示问题 */
           .editor-container :global(img) {
             max-width: 100%;
             height: auto;
           }
         `}</style>
       </div>
     );
   }
   ```

### 5.2 图片上传问题

#### 5.2.1 问题描述

富文本编辑器中上传图片失败，或上传后图片无法显示，或图片路径错误。

#### 5.2.2 可能原因

1. 上传接口配置错误
2. 文件大小或类型限制
3. 权限验证问题
4. 图片路径处理不正确

#### 5.2.3 解决方案

1. **上传接口配置**

   ```javascript
   // 后端图片上传接口
   router.post('/api/upload/image', auth, upload.single('image'), async (req, res) => {
     try {
       // 检查是否有文件上传
       if (!req.file) {
         return res.status(400).json({ message: '没有上传文件' });
       }
       
       // 检查文件类型
       const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
       if (!allowedTypes.includes(req.file.mimetype)) {
         return res.status(400).json({ message: '不支持的文件类型' });
       }
       
       // 检查文件大小
       const maxSize = 2 * 1024 * 1024; // 2MB
       if (req.file.size > maxSize) {
         return res.status(400).json({ message: '文件大小超过限制' });
       }
       
       // 生成文件名和路径
       const fileName = `${Date.now()}-${req.file.originalname}`;
       const filePath = path.join(__dirname, '../public/uploads', fileName);
       
       // 确保上传目录存在
       await fs.promises.mkdir(path.dirname(filePath), { recursive: true });
       
       // 写入文件
       await fs.promises.writeFile(filePath, req.file.buffer);
       
       // 返回文件URL
       const fileUrl = `/uploads/${fileName}`;
       
       // 记录上传信息
       await db.collection('uploads').insertOne({
         userId: req.user.id,
         fileName,
         originalName: req.file.originalname,
         mimeType: req.file.mimetype,
         size: req.file.size,
         path: fileUrl,
         createdAt: new Date()
       });
       
       return res.json({
         success: true,
         url: fileUrl
       });
     } catch (error) {
       console.error('图片上传错误:', error);
       return res.status(500).json({ message: '图片上传失败' });
     }
   });
   ```

2. **前端上传配置**

   ```javascript
   // 配置编辑器的图片上传
   function configureImageUpload(editor) {
     // 图片上传配置
     editor.config.uploadImgServer = '/api/upload/image';
     editor.config.uploadImgMaxSize = 2 * 1024 * 1024; // 2MB
     editor.config.uploadImgMaxLength = 5; // 一次最多上传 5 张图片
     editor.config.uploadFileName = 'image';
     
     // 设置请求头
     editor.config.uploadImgHeaders = {
       Authorization: `Bearer ${localStorage.getItem('token')}`
     };
     
     // 自定义上传参数
     editor.config.uploadImgParams = {
       source: 'editor'
     };
     
     // 配置 XHR withCredentials
     editor.config.withCredentials = true;
     
     // 自定义上传图片的回调函数
     editor.config.customUploadImg = function(resultFiles, insertImgFn) {
       // resultFiles 是 input 中选中的文件列表
       // insertImgFn 是获取图片 url 后，插入到编辑器的方法
       
       // 上传图片，返回结果，将图片插入到编辑器中
       Array.from(resultFiles).forEach(async file => {
         try {
           const imageUrl = await uploadImage(file);
           if (imageUrl) {
             // 插入图片到编辑器
             insertImgFn(imageUrl);
           }
         } catch (error) {
           console.error('自定义上传图片失败:', error);
           message.error('图片上传失败，请重试');
         }
       });
     };
   }
   ```

3. **权限验证修复**

   ```javascript
   // 前端请求拦截器，添加认证信息
   axios.interceptors.request.use(
     config => {
       // 获取 token
       const token = localStorage.getItem('token');
       
       // 如果有 token，添加到请求头
       if (token) {
         config.headers.Authorization = `Bearer ${token}`;
       }
       
       return config;
     },
     error => {
       return Promise.reject(error);
     }
   );
   
   // 后端认证中间件
   function auth(req, res, next) {
     try {
       // 获取请求头中的 Authorization
       const authHeader = req.headers.authorization;
       
       if (!authHeader || !authHeader.startsWith('Bearer ')) {
         return res.status(401).json({ message: '未授权，请先登录' });
       }
       
       // 提取 token
       const token = authHeader.split(' ')[1];
       
       if (!token) {
         return res.status(401).json({ message: '未授权，请先登录' });
       }
       
       // 验证 token
       const decoded = jwt.verify(token, process.env.JWT_SECRET);
       
       // 将用户信息添加到请求对象
       req.user = decoded;
       
       next();
     } catch (error) {
       console.error('认证错误:', error);
       
       if (error.name === 'TokenExpiredError') {
         return res.status(401).json({ message: '登录已过期，请重新登录' });
       }
       
       return res.status(401).json({ message: '未授权，请先登录' });
     }
   }
   ```

4. **图片路径处理**

   ```javascript
   // 处理编辑器中的图片路径
   function processEditorImages() {
     // 获取所有编辑器中的图片
     const editorImages = document.querySelectorAll('.w-e-text img');
     
     // 处理每个图片
     editorImages.forEach(img => {
       const src = img.getAttribute('src');
       
       // 检查是否是相对路径
       if (src && src.startsWith('/uploads/')) {
         // 转换为绝对路径
         img.setAttribute('src', `${process.env.REACT_APP_API_URL}${src}`);
       }
       
       // 添加加载错误处理
       img.onerror = function() {
         this.onerror = null;
         this.src = '/assets/images/image-error.png';
         this.setAttribute('data-error', 'true');
         this.setAttribute('title', '图片加载失败');
       };
       
       // 添加响应式样式
       img.style.maxWidth = '100%';
       img.style.height = 'auto';
     });
   }
   
   // 在编辑器内容变化时处理图片
   function handleEditorChange(html) {
     // 更新表单值
     form.setFieldsValue({ content: html });
     
     // 延迟处理图片，确保 DOM 已更新
     setTimeout(() => {
       processEditorImages();
     }, 100);
   }
   ```

## 6. 性能优化问题

### 6.1 页面加载缓慢

#### 6.1.1 问题描述

系统页面加载速度慢，特别是在首次加载或数据量大的页面上表现明显。

#### 6.1.2 可能原因

1. 资源文件过大
2. 组件渲染效率低
3. 数据请求过多或过大
4. 未实施代码分割

#### 6.1.3 解决方案

1. **资源优化**

   ```javascript
   // webpack 配置优化
   module.exports = {
     // 其他配置...
     optimization: {
       // 分割代码块
       splitChunks: {
         chunks: 'all',
         minSize: 30000,
         maxSize: 0,
         minChunks: 1,
         maxAsyncRequests: 5,
         maxInitialRequests: 3,
         automaticNameDelimiter: '~',
         name: true,
         cacheGroups: {
           vendors: {
             test: /[\\/]node_modules[\\/]/,
             priority: -10
           },
           default: {
             minChunks: 2,
             priority: -20,
             reuseExistingChunk: true
           }
         }
       },
       // 将 webpack 运行时代码提取到单独的 chunk
       runtimeChunk: 'single'
     },
     // 生产环境配置
     performance: {
       hints: 'warning',
       maxEntrypointSize: 512000,
       maxAssetSize: 512000
     }
   };
   ```

2. **组件优化**

   ```javascript
   // 使用 React.memo 优化组件渲染
   const NewsItem = React.memo(function NewsItem({ news, onEdit, onDelete }) {
     // 组件实现...
     return (
       <Card
         title={news.title}
         extra={
           <Space>
             <Button type="link" onClick={() => onEdit(news)}>编辑</Button>
             <Button type="link" danger onClick={() => onDelete(news)}>删除</Button>
           </Space>
         }
       >
         <p>{news.summary}</p>
         <div className="news-meta">
           <span>分类: {news.categoryName}</span>
           <span>状态: {getStatusText(news.status)}</span>
           <span>创建时间: {formatDate(news.createdAt)}</span>
         </div>
       </Card>
     );
   }, (prevProps, nextProps) => {
     // 自定义比较函数，只有在关键属性变化时才重新渲染
     return (
       prevProps.news.id === nextProps.news.id &&
       prevProps.news.title === nextProps.news.title &&
       prevProps.news.summary === nextProps.news.summary &&
       prevProps.news.status === nextProps.news.status
     );
   });
   
   // 使用 useMemo 优化计算属性
   function NewsList({ newsList, categoryMap }) {
     // 使用 useMemo 缓存计算结果
     const processedNewsList = useMemo(() => {
       return newsList.map(news => ({
         ...news,
         categoryName: categoryMap[news.categoryId] || '未分类'
       }));
     }, [newsList, categoryMap]);
     
     // 使用 useMemo 缓存统计数据
     const statistics = useMemo(() => {
       return {
         total: newsList.length,
         published: newsList.filter(n => n.publishStatus === NEWS_STATUS.PUBLISHED).length,
         pending: newsList.filter(n => n.auditStatus === NEWS_STATUS.PENDING).length
       };
     }, [newsList]);
     
     return (
       <div>
         <div className="statistics">
           <Statistic title="总数" value={statistics.total} />
           <Statistic title="已发布" value={statistics.published} />
           <Statistic title="待审核" value={statistics.pending} />
         </div>
         <List
           dataSource={processedNewsList}
           renderItem={news => (
             <List.Item>
               <NewsItem news={news} onEdit={handleEdit} onDelete={handleDelete} />
             </List.Item>
           )}
         />
       </div>
     );
   }
   ```

3. **数据请求优化**

   ```javascript
   // 使用 React Query 优化数据请求
   function useNewsList(params) {
     return useQuery(
       ['newsList', params],
       () => fetchNewsList(params),
       {
         keepPreviousData: true,
         staleTime: 5 * 60 * 1000, // 5分钟内不重新请求
         cacheTime: 10 * 60 * 1000, // 缓存10分钟
         refetchOnWindowFocus: false,
         onError: (error) => {
           message.error(`获取新闻列表失败: ${error.message}`);
         }
       }
     );
   }
   
   // 分页加载数据
   function NewsListPage() {
     const [params, setParams] = useState({
       page: 1,
       pageSize: 10,
       status: 'all',
       keyword: ''
     });
     
     // 使用自定义 Hook 获取数据
     const { data, isLoading, isFetching } = useNewsList(params);
     
     // 处理分页变化
     const handlePageChange = (page, pageSize) => {
       setParams(prev => ({
         ...prev,
         page,
         pageSize
       }));
     };
     
     // 处理筛选变化
     const handleFilterChange = (values) => {
       setParams(prev => ({
         ...prev,
         page: 1, // 重置到第一页
         ...values
       }));
     };
     
     return (
       <div className="news-list-page">
         <NewsFilter onFilterChange={handleFilterChange} />
         
         {isLoading ? (
           <div className="loading-container">
             <Spin size="large" />
           </div>
         ) : (
           <>
             <NewsList newsList={data?.items || []} />
             
             <Pagination
               current={params.page}
               pageSize={params.pageSize}
               total={data?.total || 0}
               onChange={handlePageChange}
               showSizeChanger
               showQuickJumper
               showTotal={total => `共 ${total} 条记录`}
               disabled={isFetching}
             />
           </>
         )}
       </div>
     );
   }
   ```

4. **代码分割实现**

   ```javascript
   // 使用 React.lazy 和 Suspense 实现代码分割
   import React, { Suspense, lazy } from 'react';
   import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';
   import { Spin } from 'antd';
   
   // 使用 lazy 导入组件
   const Login = lazy(() => import('./pages/Login'));
   const Dashboard = lazy(() => import('./pages/Dashboard'));
   const NewsList = lazy(() => import('./pages/news/NewsList'));
   const NewsCreate = lazy(() => import('./pages/news/NewsCreate'));
   const NewsEdit = lazy(() => import('./pages/news/NewsEdit'));
   const UserManagement = lazy(() => import('./pages/user/UserManagement'));
   const RoleManagement = lazy(() => import('./pages/role/RoleManagement'));
   
   // 加载中组件
   const Loading = () => (
     <div className="page-loading">
       <Spin size="large" />
       <p>页面加载中...</p>
     </div>
   );
   
   function App() {
     return (
       <Router>
         <Suspense fallback={<Loading />}>
           <Switch>
             <Route path="/login" component={Login} />
             <Route path="/" exact component={Dashboard} />
             <Route path="/news" exact component={NewsList} />
             <Route path="/news/create" component={NewsCreate} />
             <Route path="/news/edit/:id" component={NewsEdit} />
             <Route path="/user" component={UserManagement} />
             <Route path="/role" component={RoleManagement} />
           </Switch>
         </Suspense>
       </Router>
     );
   }
   
   export default App;
   ```

### 6.2 数据加载与缓存问题

#### 6.2.1 问题描述

频繁请求相同数据导致性能下降，或数据缓存策略不当导致显示过期数据。

#### 6.2.2 可能原因

1. 缺少数据缓存机制
2. 缓存失效策略不合理
3. 重复请求相同数据
4. 数据更新后未刷新缓存

#### 6.2.3 解决方案

1. **前端缓存实现**

   ```javascript
   // 简单的缓存管理器
   class CacheManager {
     constructor(defaultExpiration = 5 * 60 * 1000) { // 默认5分钟
       this.cache = {};
       this.defaultExpiration = defaultExpiration;
     }
     
     // 设置缓存
     set(key, data, expiration = this.defaultExpiration) {
       const now = Date.now();
       this.cache[key] = {
         data,
         expiration: now + expiration,
         timestamp: now
       };
     }
     
     // 获取缓存
     get(key) {
       const cached = this.cache[key];
       
       // 检查是否存在缓存
       if (!cached) {
         return null;
       }
       
       // 检查是否过期
       if (Date.now() > cached.expiration) {
         this.remove(key);
         return null;
       }
       
       return cached.data;
     }
     
     // 移除缓存
     remove(key) {
       delete this.cache[key];
     }
     
     // 清除所有缓存
     clear() {
       this.cache = {};
     }
     
     // 清除过期缓存
     clearExpired() {
       const now = Date.now();
       Object.keys(this.cache).forEach(key => {
         if (now > this.cache[key].expiration) {
           this.remove(key);
         }
       });
     }
   }
   
   // 创建缓存实例
   const dataCache = new CacheManager();
   
   // 使用缓存的数据请求
   async function fetchDataWithCache(url, params, expiration) {
     // 生成缓存键
     const cacheKey = `${url}:${JSON.stringify(params)}`;
     
     // 尝试从缓存获取
     const cachedData = dataCache.get(cacheKey);
     if (cachedData) {
       console.log('从缓存获取数据:', cacheKey);
       return cachedData;
     }
     
     // 缓存未命中，发送请求
     try {
       console.log('从服务器获取数据:', cacheKey);
       const response = await axios.get(url, { params });
       const data = response.data;
       
       // 缓存结果
       dataCache.set(cacheKey, data, expiration);
       
       return data;
     } catch (error) {
       console.error('获取数据失败:', error);
       throw error;
     }
   }
   ```

2. **缓存失效策略**

   ```javascript
   // 缓存失效策略
   const CACHE_STRATEGIES = {
     // 不同类型数据的缓存时间
     EXPIRATION_TIMES: {
       NEWS_LIST: 2 * 60 * 1000,       // 新闻列表缓存2分钟
       NEWS_DETAIL: 5 * 60 * 1000,     // 新闻详情缓存5分钟
       CATEGORY_LIST: 10 * 60 * 1000,  // 分类列表缓存10分钟
       USER_LIST: 5 * 60 * 1000,       // 用户列表缓存5分钟
       ROLE_LIST: 10 * 60 * 1000,      // 角色列表缓存10分钟
       DASHBOARD_STATS: 1 * 60 * 1000  // 仪表盘统计数据缓存1分钟
     },
     
     // 需要立即失效的操作
     INVALIDATION_ACTIONS: {
       // 新闻相关
       'news:create': ['NEWS_LIST', 'DASHBOARD_STATS'],
       'news:update': ['NEWS_LIST', 'NEWS_DETAIL', 'DASHBOARD_STATS'],
       'news:delete': ['NEWS_LIST', 'DASHBOARD_STATS'],
       'news:publish': ['NEWS_LIST', 'NEWS_DETAIL', 'DASHBOARD_STATS'],
       
       // 分类相关
       'category:create': ['CATEGORY_LIST'],
       'category:update': ['CATEGORY_LIST', 'NEWS_LIST'],
       'category:delete': ['CATEGORY_LIST', 'NEWS_LIST'],
       
       // 用户相关
       'user:create': ['USER_LIST'],
       'user:update': ['USER_LIST'],
       'user:delete': ['USER_LIST'],
       
       // 角色相关
       'role:create': ['ROLE_LIST'],
       'role:update': ['ROLE_LIST', 'USER_LIST'],
       'role:delete': ['ROLE_LIST']
     }
   };
   
   // 根据操作类型使缓存失效
   function invalidateCache(action) {
     const typesToInvalidate = CACHE_STRATEGIES.INVALIDATION_ACTIONS[action] || [];
     
     if (typesToInvalidate.length === 0) {
       return;
     }
     
     console.log(`根据操作 ${action} 使缓存失效:`, typesToInvalidate);
     
     // 清除指定类型的缓存
     Object.keys(dataCache.cache).forEach(key => {
       typesToInvalidate.forEach(type => {
         if (key.startsWith(type)) {
           dataCache.remove(key);
           console.log(`已清除缓存: ${key}`);
         }
       });
     });
   }
   ```

3. **避免重复请求**

   ```javascript
   // 请求去重管理器
   class RequestDeduplicator {
     constructor() {
       this.pendingRequests = {};
     }
     
     // 执行请求，如果相同请求正在进行中，则复用 Promise
     async execute(key, requestFn) {
       // 检查是否有相同的请求正在进行中
       if (this.pendingRequests[key]) {
         console.log(`复用正在进行的请求: ${key}`);
         return this.pendingRequests[key];
       }
       
       // 创建新请求
       try {
         console.log(`执行新请求: ${key}`);
         // 保存请求 Promise
         this.pendingRequests[key] = requestFn();
         
         // 等待请求完成
         const result = await this.pendingRequests[key];
         
         // 请求完成后，删除记录
         delete this.pendingRequests[key];
         
         return result;
       } catch (error) {
         // 请求失败，也需要删除记录
         delete this.pendingRequests[key];
         throw error;
       }
     }
     
     // 取消请求
     cancel(key) {
       delete this.pendingRequests[key];
     }
     
     // 检查请求是否正在进行中
     isPending(key) {
       return !!this.pendingRequests[key];
     }
   }
   
   // 创建请求去重实例
   const requestDeduplicator = new RequestDeduplicator();
   
   // 使用去重的数据请求
   async function fetchDataWithDeduplication(url, params) {
     // 生成请求键
     const requestKey = `${url}:${JSON.stringify(params)}`;
     
     // 执行请求，如果相同请求正在进行中，则复用
     return requestDeduplicator.execute(requestKey, async () => {
       const response = await axios.get(url, { params });
       return response.data;
     });
   }
   ```

4. **数据更新与缓存刷新**

   ```javascript
   // 数据更新后刷新缓存
   async function updateDataAndRefreshCache(url, data, cacheKeys) {
     try {
       // 发送更新请求
       const response = await axios.put(url, data);
       
       // 更新成功后，清除相关缓存
       if (response.data.success) {
         if (Array.isArray(cacheKeys)) {
           // 清除指定的缓存键
           cacheKeys.forEach(key => dataCache.remove(key));
         } else if (typeof cacheKeys === 'string') {
           // 使用操作类型使缓存失效
           invalidateCache(cacheKeys);
         }
         
         message.success('更新成功');
         return response.data;
       } else {
         message.error(`更新失败: ${response.data.message}`);
         return null;
       }
     } catch (error) {
       console.error('更新数据失败:', error);
       message.error(`更新失败: ${error.message}`);
       return null;
     }
   }
   
   // 使用示例
   async function updateNews(newsId, newsData) {
     // 更新新闻并刷新相关缓存
     return updateDataAndRefreshCache(
       `/api/news/${newsId}`,
       newsData,
       'news:update'
     );
   }
   ```

## 7. 附录：常用调试技巧

### 7.1 前端调试技巧

1. **使用 React DevTools**

   安装 React DevTools 浏览器扩展，可以查看组件层次结构、props、state 和性能信息。

2. **使用 Redux DevTools**

   安装 Redux DevTools 浏览器扩展，可以查看 Redux 状态变化和操作历史。

3. **控制台调试**

   ```javascript
   // 在关键位置添加日志
   console.log('组件渲染:', props);
   console.log('状态更新:', newState);
   console.log('API 响应:', response.data);
   
   // 使用 console.table 显示表格数据
   console.table(newsList);
   
   // 使用 console.group 分组日志
   console.group('用户登录流程');
   console.log('1. 表单验证');
   console.log('2. 发送请求');
   console.log('3. 处理响应');
   console.groupEnd();
   
   // 使用 console.time 测量性能
   console.time('数据加载');
   await fetchData();
   console.timeEnd('数据加载');
   ```

4. **断点调试**

   - 在代码中添加 `debugger;` 语句
   - 使用浏览器开发工具的 Sources 面板设置断点
   - 使用条件断点针对特定情况调试

### 7.2 后端调试技巧

1. **使用 Postman 测试 API**

   创建 API 请求集合，保存常用请求和测试用例。

2. **日志记录**

   ```javascript
   // 配置日志记录
   const winston = require('winston');
   
   const logger = winston.createLogger({
     level: 'info',
     format: winston.format.combine(
       winston.format.timestamp(),
       winston.format.json()
     ),
     defaultMeta: { service: 'news-api' },
     transports: [
       new winston.transports.File({ filename: 'error.log', level: 'error' }),
       new winston.transports.File({ filename: 'combined.log' })
     ]
   });
   
   // 在开发环境下，同时输出到控制台
   if (process.env.NODE_ENV !== 'production') {
     logger.add(new winston.transports.Console({
       format: winston.format.simple()
     }));
   }
   
   // 使用日志记录
   logger.info('用户登录', { userId: user.id, username: user.username });
   logger.error('数据库连接失败', { error: err.message, stack: err.stack });
   ```

3. **使用 Node.js 调试器**

   ```bash
   # 启动调试模式
   node --inspect src/index.js
   
   # 在代码中的第一行设置断点
   node --inspect-brk src/index.js
   ```

4. **数据库查询调试**

   ```javascript
   // MongoDB 查询调试
   const debugQuery = async (collection, query, options = {}) => {
     console.log(`查询集合: ${collection}`);
     console.log('查询条件:', JSON.stringify(query, null, 2));
     console.log('查询选项:', JSON.stringify(options, null, 2));
     
     const startTime = Date.now();
     const result = await db.collection(collection).find(query, options).toArray();
     const duration = Date.now() - startTime;
     
     console.log(`查询耗时: ${duration}ms`);
     console.log(`返回结果数: ${result.length}`);
     
     return result;
   };
   ```

### 7.3 性能分析技巧

1. **React 性能分析**

   ```javascript
   // 使用 React Profiler API
   import { Profiler } from 'react';
   
   function onRenderCallback(id, phase, actualDuration, baseDuration, startTime, commitTime) {
     console.log({
       id,                // 发生提交的 Profiler 树的 "id"
       phase,             // "mount" 或 "update"
       actualDuration,    // 本次更新渲染花费的时间
       baseDuration,      // 不使用缓存时渲染整棵子树需要的时间
       startTime,         // 本次更新开始渲染的时间戳
       commitTime         // 本次更新被提交的时间戳
     });
   }
   
   function MyComponent() {
     return (
       <Profiler id="MyComponent" onRender={onRenderCallback}>
         {/* 组件内容 */}
       </Profiler>
     );
   }
   ```

2. **网络性能分析**

   ```javascript
   // 使用 Performance API 测量网络请求
   async function measureNetworkRequest(url, params) {
     const start = performance.now();
     
     try {
       const response = await axios.get(url, { params });
       
       const end = performance.now();
       const duration = end - start;
       
       console.log(`请求 ${url} 耗时: ${duration.toFixed(2)}ms`);
       console.log(`响应大小: ${JSON.stringify(response.data).length} 字节`);
       
       return response.data;
     } catch (error) {
       const end = performance.now();
       console.error(`请求 ${url} 失败，耗时: ${(end - start).toFixed(2)}ms`);
       throw error;
     }
   }
   ```

3. **内存使用分析**

   ```javascript
   // 监控组件内存使用
   class MemoryMonitor extends React.Component {
     componentDidMount() {
       this.memoryInterval = setInterval(() => {
         if (window.performance && window.performance.memory) {
           const { usedJSHeapSize, totalJSHeapSize } = window.performance.memory;
           console.log(`内存使用: ${(usedJSHeapSize / 1048576).toFixed(2)}MB / ${(totalJSHeapSize / 1048576).toFixed(2)}MB`);
         }
       }, 5000);
     }
     
     componentWillUnmount() {
       clearInterval(this.memoryInterval);
     }
     
     render() {
       return this.props.children;
     }
   }
   ```